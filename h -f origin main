[1mdiff --git a/.env.development b/.env.development[m
[1mnew file mode 100644[m
[1mindex 0000000..18191e8[m
[1m--- /dev/null[m
[1m+++ b/.env.development[m
[36m@@ -0,0 +1,27 @@[m
[32m+[m[32m# Server Configuration[m
[32m+[m[32mCONVEYOR_PORT=8080[m
[32m+[m[32mCONVEYOR_HOST=0.0.0.0[m
[32m+[m[32mCONVEYOR_LOG_LEVEL=debug[m
[32m+[m
[32m+[m[32m# Data Storage[m
[32m+[m[32mCONVEYOR_DATA_DIR=./data[m
[32m+[m[32mCONVEYOR_PLUGINS_DIR=./plugins[m
[32m+[m
[32m+[m[32m# Redis Configuration[m
[32m+[m[32mREDIS_HOST=localhost[m
[32m+[m[32mREDIS_PORT=6379[m
[32m+[m[32mREDIS_PASSWORD=[m
[32m+[m
[32m+[m[32m# Security[m
[32m+[m[32mCONVEYOR_JWT_SECRET=your-development-secret-key[m
[32m+[m[32mCONVEYOR_JWT_EXPIRY=24h[m
[32m+[m
[32m+[m[32m# Feature Flags[m
[32m+[m[32mENABLE_WEBSOCKET=true[m
[32m+[m[32mENABLE_METRICS=true[m
[32m+[m[32mENABLE_TRACING=true[m
[32m+[m
[32m+[m[32m# Development Settings[m
[32m+[m[32mSKIP_AUTH=true[m
[32m+[m[32mENABLE_CORS=true[m
[32m+[m[32mENABLE_DEBUG_ENDPOINTS=true[m[41m [m
\ No newline at end of file[m
[1mdiff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml[m
[1mnew file mode 100644[m
[1mindex 0000000..f637bf3[m
[1m--- /dev/null[m
[1m+++ b/.github/workflows/ci.yml[m
[36m@@ -0,0 +1,111 @@[m
[32m+[m[32mname: CI Pipeline[m
[32m+[m
[32m+[m[32mon:[m
[32m+[m[32m  push:[m
[32m+[m[32m    branches: [ main, develop ][m
[32m+[m[32m  pull_request:[m
[32m+[m[32m    branches: [ main, develop ][m
[32m+[m
[32m+[m[32menv:[m
[32m+[m[32m  DOCKER_BUILDKIT: 1[m
[32m+[m[32m  COMPOSE_DOCKER_CLI_BUILD: 1[m
[32m+[m
[32m+[m[32mjobs:[m
[32m+[m[32m  test:[m
[32m+[m[32m    name: Run Tests[m
[32m+[m[32m    runs-on: ubuntu-latest[m
[32m+[m[32m    strategy:[m
[32m+[m[32m      matrix:[m
[32m+[m[32m        node-version: [16.x, 18.x][m
[32m+[m[32m        os: [ubuntu-latest, windows-latest][m
[32m+[m
[32m+[m[32m    steps:[m
[32m+[m[32m    - uses: actions/checkout@v3[m
[32m+[m[41m    [m
[32m+[m[32m    - name: Use Node.js ${{ matrix.node-version }}[m
[32m+[m[32m      uses: actions/setup-node@v3[m
[32m+[m[32m      with:[m
[32m+[m[32m        node-version: ${{ matrix.node-version }}[m
[32m+[m[32m        cache: 'npm'[m
[32m+[m[41m        [m
[32m+[m[32m    - name: Install dependencies[m
[32m+[m[32m      run: npm ci[m
[32m+[m[41m      [m
[32m+[m[32m    - name: Run unit tests[m
[32m+[m[32m      run: npm test[m
[32m+[m[41m      [m
[32m+[m[32m    - name: Run integration tests[m
[32m+[m[32m      run: npm run test:integration[m
[32m+[m[41m      [m
[32m+[m[32m    - name: Upload test results[m
[32m+[m[32m      uses: actions/upload-artifact@v3[m
[32m+[m[32m      if: always()[m
[32m+[m[32m      with:[m
[32m+[m[32m        name: test-results-${{ matrix.node-version }}-${{ matrix.os }}[m
[32m+[m[32m        path: |[m
[32m+[m[32m          test-results/[m
[32m+[m[32m          coverage/[m
[32m+[m
[32m+[m[32m  security:[m
[32m+[m[32m    name: Security Scan[m
[32m+[m[32m    runs-on: ubuntu-latest[m
[32m+[m[32m    steps:[m
[32m+[m[32m    - uses: actions/checkout@v3[m
[32m+[m[41m    [m
[32m+[m[32m    - name: Run SAST scan[m
[32m+[m[32m      uses: github/codeql-action/analyze@v2[m
[32m+[m[32m      with:[m
[32m+[m[32m        languages: javascript[m
[32m+[m[41m        [m
[32m+[m[32m    - name: Run dependency scan[m
[32m+[m[32m      run: npm audit[m
[32m+[m[41m      [m
[32m+[m[32m    - name: Run container scan[m
[32m+[m[32m      uses: aquasecurity/trivy-action@master[m
[32m+[m[32m      with:[m
[32m+[m[32m        image-ref: ${{ github.repository }}:${{ github.sha }}[m
[32m+[m[32m        format: 'table'[m
[32m+[m[32m        exit-code: '1'[m
[32m+[m[32m        ignore-unfixed: true[m
[32m+[m[32m        vuln-type: 'os,library'[m
[32m+[m[32m        severity: 'CRITICAL,HIGH'[m
[32m+[m
[32m+[m[32m  build:[m
[32m+[m[32m    name: Build and Package[m
[32m+[m[32m    needs: [test, security][m
[32m+[m[32m    runs-on: ubuntu-latest[m
[32m+[m[32m    steps:[m
[32m+[m[32m    - uses: actions/checkout@v3[m
[32m+[m[41m    [m
[32m+[m[32m    - name: Set up Docker Buildx[m
[32m+[m[32m      uses: docker/setup-buildx-action@v2[m
[32m+[m[41m      [m
[32m+[m[32m    - name: Login to Container Registry[m
[32m+[m[32m      uses: docker/login-action@v2[m
[32m+[m[32m      with:[m
[32m+[m[32m        registry: ${{ secrets.REGISTRY_URL }}[m
[32m+[m[32m        username: ${{ secrets.REGISTRY_USERNAME }}[m
[32m+[m[32m        password: ${{ secrets.REGISTRY_PASSWORD }}[m
[32m+[m[41m        [m
[32m+[m[32m    - name: Build and push[m
[32m+[m[32m      uses: docker/build-push-action@v4[m
[32m+[m[32m      with:[m
[32m+[m[32m        context: .[m
[32m+[m[32m        push: true[m
[32m+[m[32m        tags: |[m
[32m+[m[32m          ${{ secrets.REGISTRY_URL }}/${{ github.repository }}:${{ github.sha }}[m
[32m+[m[32m          ${{ secrets.REGISTRY_URL }}/${{ github.repository }}:latest[m
[32m+[m[32m        cache-from: type=gha[m
[32m+[m[32m        cache-to: type=gha,mode=max[m
[32m+[m[41m        [m
[32m+[m[32m    - name: Generate SBOM[m
[32m+[m[32m      run: |[m
[32m+[m[32m        docker run --rm -v $(pwd):/app -w /app cyclonedx/cyclonedx-cli generate[m
[32m+[m[41m        [m
[32m+[m[32m    - name: Upload artifacts[m
[32m+[m[32m      uses: actions/upload-artifact@v3[m
[32m+[m[32m      with:[m
[32m+[m[32m        name: build-artifacts[m
[32m+[m[32m        path: |[m
[32m+[m[32m          dist/[m
[32m+[m[32m          *.sbom.json[m[41m [m
\ No newline at end of file[m
[1mdiff --git a/.gitignore b/.gitignore[m
[1mnew file mode 100644[m
[1mindex 0000000..b2ea178[m
[1m--- /dev/null[m
[1m+++ b/.gitignore[m
[36m@@ -0,0 +1,73 @@[m
[32m+[m[32m# Go specific[m
[32m+[m[32m*.exe[m
[32m+[m[32m*.exe~[m
[32m+[m[32m*.dll[m
[32m+[m[32m*.so[m
[32m+[m[32m*.dylib[m
[32m+[m[32m*.test[m
[32m+[m[32m*.out[m
[32m+[m[32mgo.work[m
[32m+[m
[32m+[m[32m# Output of the go coverage tool[m
[32m+[m[32m*.cover[m
[32m+[m
[32m+[m[32m# Dependency directories[m
[32m+[m[32mvendor/[m
[32m+[m[32mdist/[m
[32m+[m[32mbin/[m
[32m+[m
[32m+[m[32m# Environment variables[m
[32m+[m[32m.env[m
[32m+[m[32m.env.local[m
[32m+[m[32m.env.development.local[m
[32m+[m[32m.env.test.local[m
[32m+[m[32m.env.production.local[m
[32m+[m
[32m+[m[32m# Frontend specific[m
[32m+[m[32mui/node_modules/[m
[32m+[m[32mui/.pnp[m
[32m+[m[32mui/.pnp.js[m
[32m+[m[32mui/coverage/[m
[32m+[m[32mui/build/[m
[32m+[m[32mui/dist/[m
[32m+[m[32mui/.DS_Store[m
[32m+[m[32mui/.env.local[m
[32m+[m[32mui/.env.development.local[m
[32m+[m[32mui/.env.test.local[m
[32m+[m[32mui/.env.production.local[m
[32m+[m[32mui/npm-debug.log*[m
[32m+[m[32mui/yarn-debug.log*[m
[32m+[m[32mui/yarn-error.log*[m
[32m+[m
[32m+[m[32m# IDE and editor directories[m
[32m+[m[32m.idea/[m
[32m+[m[32m.vscode/[m
[32m+[m[32m*.swp[m
[32m+[m[32m*.swo[m
[32m+[m[32m*~[m
[32m+[m[32m.DS_Store[m
[32m+[m
[32m+[m[32m# Logs[m
[32m+[m[32mlogs/[m
[32m+[m[32m*.log[m
[32m+[m[32mnpm-debug.log*[m
[32m+[m[32myarn-debug.log*[m
[32m+[m[32myarn-error.log*[m
[32m+[m
[32m+[m[32m# build and test artifacts[m
[32m+[m[32m*.tsbuildinfo[m
[32m+[m[32msecurity-reports/[m
[32m+[m[32m/tmp/[m
[32m+[m
[32m+[m[32m# Docker[m
[32m+[m[32mdocker-compose.override.yml[m
[32m+[m[32m.docker/[m
[32m+[m
[32m+[m[32m# Debug[m
[32m+[m[32m__debug_bin[m
[32m+[m[32mdebug.test[m
[32m+[m[32mdebug[m
[32m+[m
[32m+[m[32m# Air hot reload[m
[32m+[m[32m.air.toml[m
[32m+[m[32mtmp/[m[41m [m
\ No newline at end of file[m
[1mdiff --git a/Dockerfile b/Dockerfile[m
[1mnew file mode 100644[m
[1mindex 0000000..d4ed3bd[m
[1m--- /dev/null[m
[1m+++ b/Dockerfile[m
[36m@@ -0,0 +1,63 @@[m
[32m+[m[32m# Build stage for Go backend[m
[32m+[m[32mFROM golang:1.21-alpine AS backend-builder[m
[32m+[m
[32m+[m[32mWORKDIR /app[m
[32m+[m
[32m+[m[32m# Install build dependencies[m
[32m+[m[32mRUN apk add --no-cache git[m
[32m+[m
[32m+[m[32m# Copy Go module files[m
[32m+[m[32mCOPY go.mod go.sum ./[m
[32m+[m[32mRUN go mod download[m
[32m+[m
[32m+[m[32m# Copy source code[m
[32m+[m[32mCOPY . .[m
[32m+[m
[32m+[m[32m# Build the backend[m
[32m+[m[32mRUN CGO_ENABLED=0 GOOS=linux go build -o conveyor ./cli[m
[32m+[m
[32m+[m[32m# Build stage for React frontend[m
[32m+[m[32mFROM node:18-alpine AS frontend-builder[m
[32m+[m
[32m+[m[32mWORKDIR /app[m
[32m+[m
[32m+[m[32m# Copy package files[m
[32m+[m[32mCOPY ui/package*.json ./[m
[32m+[m[32mRUN npm install[m
[32m+[m
[32m+[m[32m# Copy source code[m
[32m+[m[32mCOPY ui/ .[m
[32m+[m
[32m+[m[32m# Build the frontend[m
[32m+[m[32mRUN npm run build[m
[32m+[m
[32m+[m[32m# Final stage[m
[32m+[m[32mFROM alpine:latest[m
[32m+[m
[32m+[m[32mWORKDIR /app[m
[32m+[m
[32m+[m[32m# Install runtime dependencies[m
[32m+[m[32mRUN apk add --no-cache ca-certificates tzdata[m
[32m+[m
[32m+[m[32m# Copy binary from backend builder[m
[32m+[m[32mCOPY --from=backend-builder /app/conveyor .[m
[32m+[m
[32m+[m[32m# Copy frontend build from frontend builder[m
[32m+[m[32mCOPY --from=frontend-builder /app/build ./ui/dist[m
[32m+[m
[32m+[m[32m# Copy configuration and plugins[m
[32m+[m[32mCOPY plugins ./plugins[m
[32m+[m[32mCOPY config ./config[m
[32m+[m
[32m+[m[32m# Create necessary directories[m
[32m+[m[32mRUN mkdir -p /app/data[m
[32m+[m
[32m+[m[32m# Expose ports[m
[32m+[m[32mEXPOSE 8080[m
[32m+[m
[32m+[m[32m# Set environment variables[m
[32m+[m[32mENV CONVEYOR_DATA_DIR=/app/data[m
[32m+[m[32mENV CONVEYOR_PLUGINS_DIR=/app/plugins[m
[32m+[m
[32m+[m[32m# Run the application[m
[32m+[m[32mCMD ["./conveyor", "serve"][m[41m [m
\ No newline at end of file[m
[1mdiff --git a/Dockerfile.dev b/Dockerfile.dev[m
[1mnew file mode 100644[m
[1mindex 0000000..6d22494[m
[1m--- /dev/null[m
[1m+++ b/Dockerfile.dev[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32mFROM golang:1.21-alpine[m
[32m+[m
[32m+[m[32mWORKDIR /app[m
[32m+[m
[32m+[m[32m# Install build dependencies and development tools[m
[32m+[m[32mRUN apk add --no-cache git curl bash[m
[32m+[m
[32m+[m[32m# Install a specific version of air that works with Go 1.21[m
[32m+[m[32mRUN go install github.com/cosmtrek/air@v1.44.0 && \[m
[32m+[m[32m  go install github.com/go-delve/delve/cmd/dlv@latest[m
[32m+[m
[32m+[m[32m# Create default Go module if it doesn't exist[m
[32m+[m[32mCOPY go.mod go.sum ./[m
[32m+[m
[32m+[m[32m# Initialize module if needed[m
[32m+[m[32mRUN grep -q "module" go.mod || echo "module github.com/chip/conveyor\n\ngo 1.21" > go.mod[m
[32m+[m
[32m+[m[32m# Download dependencies if any are specified (will be skipped if go.mod is empty)[m
[32m+[m[32mRUN go mod download || true[m
[32m+[m
[32m+[m[32m# Copy config files for air[m
[32m+[m[32mCOPY .air.toml ./[m
[32m+[m
[32m+[m[32m# Expose API port and delve debugging port[m
[32m+[m[32mEXPOSE 8080 2345[m
[32m+[m
[32m+[m[32m# Start the development server with hot-reloading[m
[32m+[m[32mCMD ["air", "-c", ".air.toml"][m[41m [m
\ No newline at end of file[m
[1mdiff --git a/LICENSE b/LICENSE[m
[1mdeleted file mode 100644[m
[1mindex a2a1369..0000000[m
[1m--- a/LICENSE[m
[1m+++ /dev/null[m
[36m@@ -1,21 +0,0 @@[m
[31m-MIT License[m
[31m-[m
[31m-Copyright (c) 2025 Chip[m
[31m-[m
[31m-Permission is hereby granted, free of charge, to any person obtaining a copy[m
[31m-of this software and associated documentation files (the "Software"), to deal[m
[31m-in the Software without restriction, including without limitation the rights[m
[31m-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell[m
[31m-copies of the Software, and to permit persons to whom the Software is[m
[31m-furnished to do so, subject to the following conditions:[m
[31m-[m
[31m-The above copyright notice and this permission notice shall be included in all[m
[31m-copies or substantial portions of the Software.[m
[31m-[m
[31m-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR[m
[31m-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,[m
[31m-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE[m
[31m-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER[m
[31m-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,[m
[31m-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE[m
[31m-SOFTWARE.[m
[1mdiff --git a/Makefile b/Makefile[m
[1mnew file mode 100644[m
[1mindex 0000000..232af62[m
[1m--- /dev/null[m
[1m+++ b/Makefile[m
[36m@@ -0,0 +1,53 @@[m
[32m+[m[32m.PHONY: build test lint clean dev docker-build docker-up docker-down[m
[32m+[m
[32m+[m[32m# Build the application[m
[32m+[m[32mbuild:[m
[32m+[m	[32mgo build -o conveyor ./cli[m
[32m+[m
[32m+[m[32m# Run tests[m
[32m+[m[32mtest:[m
[32m+[m	[32mgo test -v ./...[m
[32m+[m
[32m+[m[32m# Run linter[m
[32m+[m[32mlint:[m
[32m+[m	[32mgolangci-lint run[m
[32m+[m
[32m+[m[32m# Clean build artifacts[m
[32m+[m[32mclean:[m
[32m+[m	[32mrm -f conveyor[m
[32m+[m	[32mrm -rf data[m
[32m+[m	[32mrm -rf ui/dist[m
[32m+[m
[32m+[m[32m# Start development environment[m
[32m+[m[32mdev:[m
[32m+[m	[32m./scripts/dev.sh[m
[32m+[m
[32m+[m[32m# Build Docker image[m
[32m+[m[32mdocker-build:[m
[32m+[m	[32mdocker-compose build[m
[32m+[m
[32m+[m[32m# Start Docker services[m
[32m+[m[32mdocker-up:[m
[32m+[m	[32mdocker-compose up -d[m
[32m+[m
[32m+[m[32m# Stop Docker services[m
[32m+[m[32mdocker-down:[m
[32m+[m	[32mdocker-compose down[m
[32m+[m
[32m+[m[32m# Install dependencies[m
[32m+[m[32mdeps:[m
[32m+[m	[32mgo mod download[m
[32m+[m	[32mgo mod tidy[m
[32m+[m	[32mcd ui && npm install[m
[32m+[m
[32m+[m[32m# Generate API documentation[m
[32m+[m[32mdocs:[m
[32m+[m	[32mswag init -g api/server.go[m
[32m+[m
[32m+[m[32m# Run security scan[m
[32m+[m[32msecurity-scan:[m
[32m+[m	[32mgosec ./...[m
[32m+[m	[32mtrivy fs .[m
[32m+[m
[32m+[m[32m# Run all checks[m
[32m+[m[32mcheck: lint test security-scan[m[41m [m
\ No newline at end of file[m
[1mdiff --git a/README.md b/README.md[m
[1mnew file mode 100644[m
[1mindex 0000000..0ecd817[m
[1m--- /dev/null[m
[1m+++ b/README.md[m
[36m@@ -0,0 +1,119 @@[m
[32m+[m[32m# Conveyor[m
[32m+[m
[32m+[m[32m**Conveyor** is a modern, extensible CI/CD platform designed for developer productivity and security. It combines the best features of existing CI/CD tools while providing a streamlined experience through a modular plugin system.[m
[32m+[m
[32m+[m[32m![Conveyor CI/CD](https://via.placeholder.com/800x400?text=Conveyor+CI/CD)[m
[32m+[m
[32m+[m[32m## Key Features[m
[32m+[m
[32m+[m[32m- **Smart Pipeline Engine**: Dynamic parallel execution with dependency management and intelligent caching[m
[32m+[m[32m- **Comprehensive Security Scanning**: Built-in security for code, dependencies, and configurations[m
[32m+[m[32m- **Plugin Architecture**: Extend functionality with plugins for various integrations[m
[32m+[m[32m- **Elegant UI**: Modern, responsive interface for monitoring and managing pipelines[m
[32m+[m[32m- **REST API**: Full API for integration with other systems[m
[32m+[m[32m- **Real-time Updates**: WebSocket support for live pipeline status updates[m
[32m+[m
[32m+[m[32m## Security Features[m
[32m+[m
[32m+[m[32mConveyor includes a robust security scanning system that provides:[m
[32m+[m
[32m+[m[32m- Secret detection to prevent credential leaks[m
[32m+[m[32m- Vulnerability scanning for dependencies[m
[32m+[m[32m- Static code analysis for security issues[m
[32m+[m[32m- License compliance checking[m
[32m+[m[32m- SBOM (Software Bill of Materials) generation[m
[32m+[m
[32m+[m[32m## Getting Started[m
[32m+[m
[32m+[m[32m### Prerequisites[m
[32m+[m
[32m+[m[32m- Go 1.21+[m
[32m+[m[32m- Node.js 18+[m
[32m+[m[32m- Docker and Docker Compose (for development)[m
[32m+[m
[32m+[m[32m### Quick Start[m
[32m+[m
[32m+[m[32m1. Clone the repository:[m
[32m+[m[32m   ```bash[m
[32m+[m[32m   git clone https://github.com/Packetz/conveyor.git[m
[32m+[m[32m   cd conveyor[m
[32m+[m[32m   ```[m
[32m+[m
[32m+[m[32m2. Start the development environment:[m
[32m+[m[32m   ```bash[m
[32m+[m[32m   ./scripts/docker-dev.sh up[m
[32m+[m[32m   ```[m
[32m+[m
[32m+[m[32m3. Access the UI at http://localhost:3000[m
[32m+[m
[32m+[m[32m### Development[m
[32m+[m
[32m+[m[32mFor development, we use Docker Compose to set up a consistent environment:[m
[32m+[m
[32m+[m[32m```bash[m
[32m+[m[32m# Start the development environment[m
[32m+[m[32m./scripts/docker-dev.sh up[m
[32m+[m
[32m+[m[32m# Rebuild services[m
[32m+[m[32m./scripts/docker-dev.sh rebuild[m
[32m+[m
[32m+[m[32m# View logs[m
[32m+[m[32m./scripts/docker-dev.sh logs[m
[32m+[m
[32m+[m[32m# Shut down[m
[32m+[m[32m./scripts/docker-dev.sh down[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32mBoth frontend and backend support hot reloading for rapid development.[m
[32m+[m
[32m+[m[32m## Architecture[m
[32m+[m
[32m+[m[32mConveyor is built with a modular architecture:[m
[32m+[m
[32m+[m[32m- **Core**: Pipeline engine written in Go[m
[32m+[m[32m- **API**: REST API and WebSocket support[m
[32m+[m[32m- **Plugins**: Extensible plugin system[m
[32m+[m[32m- **UI**: React/TypeScript frontend[m
[32m+[m
[32m+[m[32m## Pipeline Configuration[m
[32m+[m
[32m+[m[32mPipelines are defined in YAML format:[m
[32m+[m
[32m+[m[32m```yaml[m
[32m+[m[32mname: sample-pipeline[m
[32m+[m[32mdescription: A sample pipeline[m
[32m+[m
[32m+[m[32mtriggers:[m
[32m+[m[32m  - type: push[m
[32m+[m[32m    branches: [main, develop][m
[32m+[m
[32m+[m[32mstages:[m
[32m+[m[32m  - name: build[m
[32m+[m[32m    steps:[m
[32m+[m[32m      - name: checkout[m
[32m+[m[32m        run: git clone https://github.com/user/repo.git[m
[32m+[m
[32m+[m[32m      - name: build[m
[32m+[m[32m        run: go build -o app ./cmd/app[m
[32m+[m
[32m+[m[32m  - name: test[m
[32m+[m[32m    steps:[m
[32m+[m[32m      - name: unit-tests[m
[32m+[m[32m        run: go test ./...[m
[32m+[m
[32m+[m[32m  - name: security[m
[32m+[m[32m    steps:[m
[32m+[m[32m      - name: security-scan[m
[32m+[m[32m        plugin: security-scanner[m
[32m+[m[32m        config:[m
[32m+[m[32m          scanTypes: [secret, vulnerability, code][m
[32m+[m[32m          severityThreshold: HIGH[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## Contributing[m
[32m+[m
[32m+[m[32mContributions are welcome! Please feel free to submit a Pull Request.[m
[32m+[m
[32m+[m[32m## License[m
[32m+[m
[32m+[m[32mThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.[m[41m [m
\ No newline at end of file[m
[1mdiff --git a/api/routes/job.go b/api/routes/job.go[m
[1mnew file mode 100644[m
[1mindex 0000000..61e043e[m
[1m--- /dev/null[m
[1m+++ b/api/routes/job.go[m
[36m@@ -0,0 +1,184 @@[m
[32m+[m[32mpackage routes[m
[32m+[m
[32m+[m[32mimport ([m
[32m+[m	[32m"net/http"[m
[32m+[m	[32m"time"[m
[32m+[m
[32m+[m	[32m"github.com/chip/conveyor/core"[m
[32m+[m	[32m"github.com/gin-gonic/gin"[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32m// RegisterJobRoutes registers all job-related routes[m
[32m+[m[32mfunc RegisterJobRoutes(router *gin.Engine, pipelineEngine *core.PipelineEngine) {[m
[32m+[m	[32mjobGroup := router.Group("/api/jobs")[m
[32m+[m	[32m{[m
[32m+[m		[32m// Get all jobs[m
[32m+[m		[32mjobGroup.GET("", func(c *gin.Context) {[m
[32m+[m			[32m// Filter by pipeline ID if provided[m
[32m+[m			[32mpipelineID := c.Query("pipelineId")[m
[32m+[m
[32m+[m			[32m// This would load from a database in a real implementation[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mjobs := []map[string]interface{}{[m
[32m+[m				[32m{[m
[32m+[m					[32m"id":         "job-123",[m
[32m+[m					[32m"pipelineId": "pipeline-1",[m
[32m+[m					[32m"status":     "running",[m
[32m+[m					[32m"startedAt":  time.Now().Add(-2 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"duration":   "1h 30m",[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"id":         "job-124",[m
[32m+[m					[32m"pipelineId": "pipeline-1",[m
[32m+[m					[32m"status":     "success",[m
[32m+[m					[32m"startedAt":  time.Now().Add(-5 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"duration":   "45m",[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"id":         "job-125",[m
[32m+[m					[32m"pipelineId": "pipeline-2",[m
[32m+[m					[32m"status":     "failed",[m
[32m+[m					[32m"startedAt":  time.Now().Add(-1 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"duration":   "20m",[m
[32m+[m				[32m},[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32m// Filter by pipeline ID if provided[m
[32m+[m			[32mif pipelineID != "" {[m
[32m+[m				[32mfilteredJobs := make([]map[string]interface{}, 0)[m
[32m+[m				[32mfor _, job := range jobs {[m
[32m+[m					[32mif job["pipelineId"] == pipelineID {[m
[32m+[m						[32mfilteredJobs = append(filteredJobs, job)[m
[32m+[m					[32m}[m
[32m+[m				[32m}[m
[32m+[m				[32mjobs = filteredJobs[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, jobs)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Get a single job[m
[32m+[m		[32mjobGroup.GET("/:id", func(c *gin.Context) {[m
[32m+[m			[32mid := c.Param("id")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would query the database[m
[32m+[m			[32m// For now, we'll return mock data[m
[32m+[m			[32mjob := map[string]interface{}{[m
[32m+[m				[32m"id":         id,[m
[32m+[m				[32m"pipelineId": "pipeline-1",[m
[32m+[m				[32m"status":     "running",[m
[32m+[m				[32m"startedAt":  time.Now().Add(-2 * time.Hour).Format(time.RFC3339),[m
[32m+[m				[32m"duration":   "1h 30m",[m
[32m+[m				[32m"steps": []map[string]interface{}{[m
[32m+[m					[32m{[m
[32m+[m						[32m"id":     "step-1",[m
[32m+[m						[32m"name":   "checkout",[m
[32m+[m						[32m"status": "success",[m
[32m+[m						[32m"output": "Checked out repository at commit abc123",[m
[32m+[m					[32m},[m
[32m+[m					[32m{[m
[32m+[m						[32m"id":     "step-2",[m
[32m+[m						[32m"name":   "build",[m
[32m+[m						[32m"status": "success",[m
[32m+[m						[32m"output": "Build completed successfully",[m
[32m+[m					[32m},[m
[32m+[m					[32m{[m
[32m+[m						[32m"id":     "step-3",[m
[32m+[m						[32m"name":   "test",[m
[32m+[m						[32m"status": "running",[m
[32m+[m						[32m"output": "Running tests...",[m
[32m+[m					[32m},[m
[32m+[m				[32m},[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, job)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Retry a job[m
[32m+[m		[32mjobGroup.POST("/:id/retry", func(c *gin.Context) {[m
[32m+[m			[32mid := c.Param("id")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would restart a job[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mnewJob := map[string]interface{}{[m
[32m+[m				[32m"id":         "job-" + time.Now().Format("20060102150405"),[m
[32m+[m				[32m"pipelineId": "pipeline-1",[m
[32m+[m				[32m"status":     "running",[m
[32m+[m				[32m"startedAt":  time.Now().Format(time.RFC3339),[m
[32m+[m				[32m"retryOf":    id,[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, newJob)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Cancel a job[m
[32m+[m		[32mjobGroup.POST("/:id/cancel", func(c *gin.Context) {[m
[32m+[m			[32mid := c.Param("id")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would cancel a running job[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mjob := map[string]interface{}{[m
[32m+[m				[32m"id":         id,[m
[32m+[m				[32m"pipelineId": "pipeline-1",[m
[32m+[m				[32m"status":     "cancelled",[m
[32m+[m				[32m"startedAt":  time.Now().Add(-2 * time.Hour).Format(time.RFC3339),[m
[32m+[m				[32m"endedAt":    time.Now().Format(time.RFC3339),[m
[32m+[m				[32m"duration":   "2h 0m",[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, job)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Get job logs[m
[32m+[m		[32mjobGroup.GET("/:id/logs", func(c *gin.Context) {[m
[32m+[m			[32mid := c.Param("id")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would fetch logs from storage[m
[32m+[m			[32m// For now, we'll return mock data[m
[32m+[m			[32mlogs := []map[string]interface{}{[m
[32m+[m				[32m{[m
[32m+[m					[32m"time":    time.Now().Add(-2 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"level":   "INFO",[m
[32m+[m					[32m"message": "Job started",[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"time":    time.Now().Add(-1*time.Hour - 45*time.Minute).Format(time.RFC3339),[m
[32m+[m					[32m"level":   "INFO",[m
[32m+[m					[32m"message": "Checking out repository",[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"time":    time.Now().Add(-1*time.Hour - 44*time.Minute).Format(time.RFC3339),[m
[32m+[m					[32m"level":   "INFO",[m
[32m+[m					[32m"message": "Repository checkout complete",[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"time":    time.Now().Add(-1*time.Hour - 40*time.Minute).Format(time.RFC3339),[m
[32m+[m					[32m"level":   "INFO",[m
[32m+[m					[32m"message": "Starting build step",[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"time":    time.Now().Add(-1 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"level":   "INFO",[m
[32m+[m					[32m"message": "Build completed successfully",[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"time":    time.Now().Add(-55 * time.Minute).Format(time.RFC3339),[m
[32m+[m					[32m"level":   "INFO",[m
[32m+[m					[32m"message": "Starting test step",[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"time":    time.Now().Add(-30 * time.Minute).Format(time.RFC3339),[m
[32m+[m					[32m"level":   "WARNING",[m
[32m+[m					[32m"message": "Test failure in module X",[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"time":    time.Now().Add(-15 * time.Minute).Format(time.RFC3339),[m
[32m+[m					[32m"level":   "INFO",[m
[32m+[m					[32m"message": "Tests completed with warnings",[m
[32m+[m				[32m},[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, logs)[m
[32m+[m		[32m})[m
[32m+[m	[32m}[m
[32m+[m[32m}[m[41m [m
\ No newline at end of file[m
[1mdiff --git a/api/routes/pipeline.go b/api/routes/pipeline.go[m
[1mnew file mode 100644[m
[1mindex 0000000..b2d006f[m
[1m--- /dev/null[m
[1m+++ b/api/routes/pipeline.go[m
[36m@@ -0,0 +1,155 @@[m
[32m+[m[32mpackage routes[m
[32m+[m
[32m+[m[32mimport ([m
[32m+[m	[32m"net/http"[m
[32m+[m	[32m"time"[m
[32m+[m
[32m+[m	[32m"github.com/chip/conveyor/core"[m
[32m+[m	[32m"github.com/gin-gonic/gin"[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32m// RegisterPipelineRoutes registers all pipeline-related routes[m
[32m+[m[32mfunc RegisterPipelineRoutes(router *gin.Engine, pipelineEngine *core.PipelineEngine) {[m
[32m+[m	[32mpipelineGroup := router.Group("/api/pipelines")[m
[32m+[m	[32m{[m
[32m+[m		[32m// Get all pipelines[m
[32m+[m		[32mpipelineGroup.GET("", func(c *gin.Context) {[m
[32m+[m			[32m// This would load from a database in a real implementation[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mpipelines := []map[string]interface{}{[m
[32m+[m				[32m{[m
[32m+[m					[32m"id":          "pipeline-1",[m
[32m+[m					[32m"name":        "Build and Test",[m
[32m+[m					[32m"description": "Builds and tests the application",[m
[32m+[m					[32m"status":      "running",[m
[32m+[m					[32m"createdAt":   time.Now().Add(-48 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"updatedAt":   time.Now().Add(-2 * time.Hour).Format(time.RFC3339),[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"id":          "pipeline-2",[m
[32m+[m					[32m"name":        "Deploy to Production",[m
[32m+[m					[32m"description": "Deploys the application to production",[m
[32m+[m					[32m"status":      "success",[m
[32m+[m					[32m"createdAt":   time.Now().Add(-24 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"updatedAt":   time.Now().Add(-12 * time.Hour).Format(time.RFC3339),[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"id":          "pipeline-3",[m
[32m+[m					[32m"name":        "Security Scan",[m
[32m+[m					[32m"description": "Performs security scanning of the codebase",[m
[32m+[m					[32m"status":      "failed",[m
[32m+[m					[32m"createdAt":   time.Now().Add(-12 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"updatedAt":   time.Now().Add(-6 * time.Hour).Format(time.RFC3339),[m
[32m+[m				[32m},[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, pipelines)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Get a single pipeline[m
[32m+[m		[32mpipelineGroup.GET("/:id", func(c *gin.Context) {[m
[32m+[m			[32mid := c.Param("id")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would query the database[m
[32m+[m			[32m// For now, we'll return mock data[m
[32m+[m			[32mpipeline := map[string]interface{}{[m
[32m+[m				[32m"id":          id,[m
[32m+[m				[32m"name":        "Build and Test",[m
[32m+[m				[32m"description": "Builds and tests the application",[m
[32m+[m				[32m"status":      "running",[m
[32m+[m				[32m"createdAt":   time.Now().Add(-48 * time.Hour).Format(time.RFC3339),[m
[32m+[m				[32m"updatedAt":   time.Now().Add(-2 * time.Hour).Format(time.RFC3339),[m
[32m+[m				[32m"stages": []map[string]interface{}{[m
[32m+[m					[32m{[m
[32m+[m						[32m"id":     "stage-1",[m
[32m+[m						[32m"name":   "Build",[m
[32m+[m						[32m"status": "success",[m
[32m+[m					[32m},[m
[32m+[m					[32m{[m
[32m+[m						[32m"id":     "stage-2",[m
[32m+[m						[32m"name":   "Test",[m
[32m+[m						[32m"status": "running",[m
[32m+[m					[32m},[m
[32m+[m					[32m{[m
[32m+[m						[32m"id":     "stage-3",[m
[32m+[m						[32m"name":   "Deploy",[m
[32m+[m						[32m"status": "pending",[m
[32m+[m					[32m},[m
[32m+[m				[32m},[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, pipeline)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Create a new pipeline[m
[32m+[m		[32mpipelineGroup.POST("", func(c *gin.Context) {[m
[32m+[m			[32mvar pipelineRequest map[string]interface{}[m
[32m+[m			[32mif err := c.ShouldBindJSON(&pipelineRequest); err != nil {[m
[32m+[m				[32mc.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format", "details": err.Error()})[m
[32m+[m				[32mreturn[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would create a pipeline in the database[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mpipeline := map[string]interface{}{[m
[32m+[m				[32m"id":          "pipeline-new",[m
[32m+[m				[32m"name":        pipelineRequest["name"],[m
[32m+[m				[32m"description": pipelineRequest["description"],[m
[32m+[m				[32m"status":      "created",[m
[32m+[m				[32m"createdAt":   time.Now().Format(time.RFC3339),[m
[32m+[m				[32m"updatedAt":   time.Now().Format(time.RFC3339),[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusCreated, pipeline)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Update a pipeline[m
[32m+[m		[32mpipelineGroup.PUT("/:id", func(c *gin.Context) {[m
[32m+[m			[32mid := c.Param("id")[m
[32m+[m
[32m+[m			[32mvar pipelineRequest map[string]interface{}[m
[32m+[m			[32mif err := c.ShouldBindJSON(&pipelineRequest); err != nil {[m
[32m+[m				[32mc.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format", "details": err.Error()})[m
[32m+[m				[32mreturn[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would update a pipeline in the database[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mpipeline := map[string]interface{}{[m
[32m+[m				[32m"id":          id,[m
[32m+[m				[32m"name":        pipelineRequest["name"],[m
[32m+[m				[32m"description": pipelineRequest["description"],[m
[32m+[m				[32m"status":      "updated",[m
[32m+[m				[32m"createdAt":   time.Now().Add(-48 * time.Hour).Format(time.RFC3339),[m
[32m+[m				[32m"updatedAt":   time.Now().Format(time.RFC3339),[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, pipeline)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Delete a pipeline[m
[32m+[m		[32mpipelineGroup.DELETE("/:id", func(c *gin.Context) {[m
[32m+[m			[32mid := c.Param("id")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would delete a pipeline from the database[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mc.JSON(http.StatusOK, gin.H{"message": "Pipeline deleted successfully", "id": id})[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Run a pipeline[m
[32m+[m		[32mpipelineGroup.POST("/:id/run", func(c *gin.Context) {[m
[32m+[m			[32mid := c.Param("id")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would start a pipeline execution[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mjob := map[string]interface{}{[m
[32m+[m				[32m"id":         "job-123",[m
[32m+[m				[32m"pipelineId": id,[m
[32m+[m				[32m"status":     "running",[m
[32m+[m				[32m"startedAt":  time.Now().Format(time.RFC3339),[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, job)[m
[32m+[m		[32m})[m
[32m+[m	[32m}[m
[32m+[m[32m}[m[41m [m
\ No newline at end of file[m
[1mdiff --git a/api/routes/plugin.go b/api/routes/plugin.go[m
[1mnew file mode 100644[m
[1mindex 0000000..6b5fca9[m
[1m--- /dev/null[m
[1m+++ b/api/routes/plugin.go[m
[36m@@ -0,0 +1,220 @@[m
[32m+[m[32mpackage routes[m
[32m+[m
[32m+[m[32mimport ([m
[32m+[m	[32m"net/http"[m
[32m+[m	[32m"time"[m
[32m+[m
[32m+[m	[32m"github.com/gin-gonic/gin"[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32m// RegisterPluginRoutes registers all plugin-related routes[m
[32m+[m[32mfunc RegisterPluginRoutes(router *gin.Engine) {[m
[32m+[m	[32mpluginGroup := router.Group("/api/plugins")[m
[32m+[m	[32m{[m
[32m+[m		[32m// Get all plugins[m
[32m+[m		[32mpluginGroup.GET("", func(c *gin.Context) {[m
[32m+[m			[32m// This would load from a plugin registry in a real implementation[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mplugins := []map[string]interface{}{[m
[32m+[m				[32m{[m
[32m+[m					[32m"name":        "security-scanner",[m
[32m+[m					[32m"version":     "2.0.0",[m
[32m+[m					[32m"description": "Comprehensive security scanner for code, dependencies, and configurations",[m
[32m+[m					[32m"author":      "Conveyor Team",[m
[32m+[m					[32m"homepage":    "https://conveyor.example.com/plugins/security",[m
[32m+[m					[32m"license":     "MIT",[m
[32m+[m					[32m"type":        "security",[m
[32m+[m					[32m"icon":        "shield-check",[m
[32m+[m					[32m"installed":   true,[m
[32m+[m					[32m"enabled":     true,[m
[32m+[m					[32m"installedAt": time.Now().Add(-7 * 24 * time.Hour).Format(time.RFC3339),[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"name":        "docker-build",[m
[32m+[m					[32m"version":     "1.2.0",[m
[32m+[m					[32m"description": "Build Docker images with advanced caching and optimization",[m
[32m+[m					[32m"author":      "Conveyor Team",[m
[32m+[m					[32m"homepage":    "https://conveyor.example.com/plugins/docker-build",[m
[32m+[m					[32m"license":     "MIT",[m
[32m+[m					[32m"type":        "builder",[m
[32m+[m					[32m"icon":        "docker",[m
[32m+[m					[32m"installed":   true,[m
[32m+[m					[32m"enabled":     true,[m
[32m+[m					[32m"installedAt": time.Now().Add(-5 * 24 * time.Hour).Format(time.RFC3339),[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"name":        "aws-deploy",[m
[32m+[m					[32m"version":     "1.0.1",[m
[32m+[m					[32m"description": "Deploy applications to AWS services",[m
[32m+[m					[32m"author":      "Conveyor Team",[m
[32m+[m					[32m"homepage":    "https://conveyor.example.com/plugins/aws-deploy",[m
[32m+[m					[32m"license":     "MIT",[m
[32m+[m					[32m"type":        "deployment",[m
[32m+[m					[32m"icon":        "cloud-upload",[m
[32m+[m					[32m"installed":   true,[m
[32m+[m					[32m"enabled":     false,[m
[32m+[m					[32m"installedAt": time.Now().Add(-2 * 24 * time.Hour).Format(time.RFC3339),[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"name":        "test-reporter",[m
[32m+[m					[32m"version":     "1.1.0",[m
[32m+[m					[32m"description": "Generate test reports with coverage metrics and visualizations",[m
[32m+[m					[32m"author":      "Conveyor Team",[m
[32m+[m					[32m"homepage":    "https://conveyor.example.com/plugins/test-reporter",[m
[32m+[m					[32m"license":     "MIT",[m
[32m+[m					[32m"type":        "reporting",[m
[32m+[m					[32m"icon":        "chart-bar",[m
[32m+[m					[32m"installed":   false,[m
[32m+[m					[32m"enabled":     false,[m
[32m+[m				[32m},[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, plugins)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Get a single plugin[m
[32m+[m		[32mpluginGroup.GET("/:name", func(c *gin.Context) {[m
[32m+[m			[32mname := c.Param("name")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would query the plugin registry[m
[32m+[m			[32m// For now, we'll return mock data based on the requested plugin name[m
[32m+[m			[32mvar plugin map[string]interface{}[m
[32m+[m
[32m+[m			[32mif name == "security-scanner" {[m
[32m+[m				[32mplugin = map[string]interface{}{[m
[32m+[m					[32m"name":        "security-scanner",[m
[32m+[m					[32m"version":     "2.0.0",[m
[32m+[m					[32m"description": "Comprehensive security scanner for code, dependencies, and configurations",[m
[32m+[m					[32m"author":      "Conveyor Team",[m
[32m+[m					[32m"homepage":    "https://conveyor.example.com/plugins/security",[m
[32m+[m					[32m"license":     "MIT",[m
[32m+[m					[32m"type":        "security",[m
[32m+[m					[32m"icon":        "shield-check",[m
[32m+[m					[32m"installed":   true,[m
[32m+[m					[32m"enabled":     true,[m
[32m+[m					[32m"installedAt": time.Now().Add(-7 * 24 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"stepTypes": []string{[m
[32m+[m						[32m"security-scan",[m
[32m+[m						[32m"vulnerability-scan",[m
[32m+[m						[32m"secret-scan",[m
[32m+[m						[32m"sbom-generate",[m
[32m+[m					[32m},[m
[32m+[m					[32m"categories": []string{[m
[32m+[m						[32m"security",[m
[32m+[m						[32m"quality",[m
[32m+[m						[32m"compliance",[m
[32m+[m					[32m},[m
[32m+[m					[32m"configSchema": map[string]interface{}{[m
[32m+[m						[32m"type": "object",[m
[32m+[m						[32m"properties": map[string]interface{}{[m
[32m+[m							[32m"severityThreshold": map[string]interface{}{[m
[32m+[m								[32m"type":        "string",[m
[32m+[m								[32m"enum":        []string{"CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"},[m
[32m+[m								[32m"default":     "HIGH",[m
[32m+[m								[32m"description": "Minimum severity level that will cause a scan to fail",[m
[32m+[m							[32m},[m
[32m+[m							[32m"scanTypes": map[string]interface{}{[m
[32m+[m								[32m"type":        "array",[m
[32m+[m								[32m"items":       map[string]interface{}{"type": "string"},[m
[32m+[m								[32m"default":     []string{"secret", "vulnerability", "code", "license"},[m
[32m+[m								[32m"description": "Types of security scans to perform",[m
[32m+[m							[32m},[m
[32m+[m						[32m},[m
[32m+[m					[32m},[m
[32m+[m				[32m}[m
[32m+[m			[32m} else {[m
[32m+[m				[32mc.JSON(http.StatusNotFound, gin.H{"error": "Plugin not found"})[m
[32m+[m				[32mreturn[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, plugin)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Install a plugin[m
[32m+[m		[32mpluginGroup.POST("/:name/install", func(c *gin.Context) {[m
[32m+[m			[32mname := c.Param("name")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would install a plugin[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mplugin := map[string]interface{}{[m
[32m+[m				[32m"name":        name,[m
[32m+[m				[32m"version":     "1.0.0",[m
[32m+[m				[32m"description": "Plugin description",[m
[32m+[m				[32m"author":      "Conveyor Team",[m
[32m+[m				[32m"installed":   true,[m
[32m+[m				[32m"enabled":     true,[m
[32m+[m				[32m"installedAt": time.Now().Format(time.RFC3339),[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, plugin)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Uninstall a plugin[m
[32m+[m		[32mpluginGroup.POST("/:name/uninstall", func(c *gin.Context) {[m
[32m+[m			[32mname := c.Param("name")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would uninstall a plugin[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mc.JSON(http.StatusOK, gin.H{"name": name, "status": "uninstalled"})[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Enable a plugin[m
[32m+[m		[32mpluginGroup.POST("/:name/enable", func(c *gin.Context) {[m
[32m+[m			[32mname := c.Param("name")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would enable a plugin[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mc.JSON(http.StatusOK, gin.H{"name": name, "enabled": true})[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Disable a plugin[m
[32m+[m		[32mpluginGroup.POST("/:name/disable", func(c *gin.Context) {[m
[32m+[m			[32mname := c.Param("name")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would disable a plugin[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mc.JSON(http.StatusOK, gin.H{"name": name, "enabled": false})[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Get plugin settings[m
[32m+[m		[32mpluginGroup.GET("/:name/settings", func(c *gin.Context) {[m
[32m+[m			[32mname := c.Param("name")[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would fetch plugin settings[m
[32m+[m			[32m// For now, we'll return mock data[m
[32m+[m			[32msettings := map[string]interface{}{[m
[32m+[m				[32m"name": name,[m
[32m+[m				[32m"config": map[string]interface{}{[m
[32m+[m					[32m"severityThreshold": "HIGH",[m
[32m+[m					[32m"ignorePatterns":    []string{"node_modules/", "vendor/", ".git/"},[m
[32m+[m					[32m"scanTypes":         []string{"secret", "vulnerability", "code", "license"},[m
[32m+[m					[32m"failOnViolation":   true,[m
[32m+[m					[32m"generateSBOM":      true,[m
[32m+[m				[32m},[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, settings)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Update plugin settings[m
[32m+[m		[32mpluginGroup.PUT("/:name/settings", func(c *gin.Context) {[m
[32m+[m			[32mname := c.Param("name")[m
[32m+[m
[32m+[m			[32mvar settingsRequest map[string]interface{}[m
[32m+[m			[32mif err := c.ShouldBindJSON(&settingsRequest); err != nil {[m
[32m+[m				[32mc.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format", "details": err.Error()})[m
[32m+[m				[32mreturn[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32m// In a real implementation, this would update plugin settings[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32msettings := map[string]interface{}{[m
[32m+[m				[32m"name":    name,[m
[32m+[m				[32m"config":  settingsRequest,[m
[32m+[m				[32m"updated": true,[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mc.JSON(http.StatusOK, settings)[m
[32m+[m		[32m})[m
[32m+[m	[32m}[m
[32m+[m[32m}[m[41m [m
\ No newline at end of file[m
[1mdiff --git a/api/routes/security.go b/api/routes/security.go[m
[1mnew file mode 100644[m
[1mindex 0000000..c9fe00d[m
[1m--- /dev/null[m
[1m+++ b/api/routes/security.go[m
[36m@@ -0,0 +1,291 @@[m
[32m+[m[32mpackage routes[m
[32m+[m
[32m+[m[32mimport ([m
[32m+[m	[32m"encoding/json"[m
[32m+[m	[32m"fmt"[m
[32m+[m	[32m"net/http"[m
[32m+[m	[32m"path/filepath"[m
[32m+[m	[32m"strconv"[m
[32m+[m	[32m"time"[m
[32m+[m
[32m+[m	[32m"github.com/chip/conveyor/core"[m
[32m+[m	[32m"github.com/chip/conveyor/plugins/security"[m
[32m+[m	[32m"github.com/gin-gonic/gin"[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32m// SecurityRequest represents a request to run a security scan[m
[32m+[m[32mtype SecurityRequest struct {[m
[32m+[m	[32mPipelineID       string   `json:"pipelineId"`[m
[32m+[m	[32mTargetDir        string   `json:"targetDir"`[m
[32m+[m	[32mScanTypes        []string `json:"scanTypes"`[m
[32m+[m	[32mSeverityThreshold string  `json:"severityThreshold"`[m
[32m+[m	[32mFailOnViolation  bool     `json:"failOnViolation"`[m
[32m+[m	[32mGenerateSBOM     bool     `json:"generateSBOM"`[m
[32m+[m	[32mCustomRules      []security.Rule `json:"customRules"`[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// RegisterSecurityRoutes registers all security-related routes[m
[32m+[m[32mfunc RegisterSecurityRoutes(router *gin.Engine, pipelineEngine *core.PipelineEngine) {[m
[32m+[m	[32msecurityGroup := router.Group("/api/security")[m
[32m+[m	[32m{[m
[32m+[m		[32m// Get security scan configuration[m
[32m+[m		[32msecurityGroup.GET("/config", func(c *gin.Context) {[m
[32m+[m			[32m// This would load from a configuration store in a real implementation[m
[32m+[m			[32mconfig := map[string]interface{}{[m
[32m+[m				[32m"scanTypes": []string{"secret", "vulnerability", "code", "license"},[m
[32m+[m				[32m"severityThreshold": "HIGH",[m
[32m+[m				[32m"ignorePatterns": []string{"node_modules/", "vendor/", ".git/"},[m
[32m+[m				[32m"failOnViolation": true,[m
[32m+[m				[32m"generateSBOM": true,[m
[32m+[m				[32m"sbomFormat": "cyclonedx",[m
[32m+[m				[32m"outputDir": "security-reports",[m
[32m+[m			[32m}[m
[32m+[m[41m			[m
[32m+[m			[32mc.JSON(http.StatusOK, config)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Run a security scan[m
[32m+[m		[32msecurityGroup.POST("/scan", func(c *gin.Context) {[m
[32m+[m			[32mvar req SecurityRequest[m
[32m+[m			[32mif err := c.ShouldBindJSON(&req); err != nil {[m
[32m+[m				[32mc.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format", "details": err.Error()})[m
[32m+[m				[32mreturn[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32m// Set defaults if not provided[m
[32m+[m			[32mif req.TargetDir == "" {[m
[32m+[m				[32mreq.TargetDir = "."[m
[32m+[m			[32m}[m
[32m+[m			[32mif len(req.ScanTypes) == 0 {[m
[32m+[m				[32mreq.ScanTypes = []string{"secret", "vulnerability", "code"}[m
[32m+[m			[32m}[m
[32m+[m			[32mif req.SeverityThreshold == "" {[m
[32m+[m				[32mreq.SeverityThreshold = "HIGH"[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32m// Create a step for the security scan[m
[32m+[m			[32mstep := core.Step{[m
[32m+[m				[32mID:   fmt.Sprintf("security-scan-%d", time.Now().Unix()),[m
[32m+[m				[32mName: "security-scan",[m
[32m+[m				[32mType: "plugin",[m
[32m+[m				[32mPlugin: "security-scanner",[m
[32m+[m				[32mConfig: map[string]interface{}{[m
[32m+[m					[32m"targetDir":         req.TargetDir,[m
[32m+[m					[32m"scanTypes":         req.ScanTypes,[m
[32m+[m					[32m"severityThreshold": req.SeverityThreshold,[m
[32m+[m					[32m"failOnViolation":   req.FailOnViolation,[m
[32m+[m					[32m"generateSBOM":      req.GenerateSBOM,[m
[32m+[m				[32m},[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32m// Add custom rules if provided[m
[32m+[m			[32mif len(req.CustomRules) > 0 {[m
[32m+[m				[32mstep.Config["customRules"] = req.CustomRules[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32m// Create a security plugin instance[m
[32m+[m			[32mplugin, err := security.NewSecurityPlugin("")[m
[32m+[m			[32mif err != nil {[m
[32m+[m				[32mc.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to initialize security scanner", "details": err.Error()})[m
[32m+[m				[32mreturn[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32m// Run the scan[m
[32m+[m			[32mctx := c.Request.Context()[m
[32m+[m			[32mresult, err := plugin.Execute(ctx, step)[m
[32m+[m			[32mif err != nil {[m
[32m+[m				[32mc.JSON(http.StatusInternalServerError, gin.H{"error": "Security scan failed", "details": err.Error()})[m
[32m+[m				[32mreturn[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32m// Return the result[m
[32m+[m			[32mc.JSON(http.StatusOK, result)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Get scan history for a pipeline[m
[32m+[m		[32msecurityGroup.GET("/history/:pipelineId", func(c *gin.Context) {[m
[32m+[m			[32mpipelineID := c.Param("pipelineId")[m
[32m+[m[41m			[m
[32m+[m			[32m// This would load from a database in a real implementation[m
[32m+[m			[32m// For now, we'll return a mock response[m
[32m+[m			[32mhistory := []map[string]interface{}{[m
[32m+[m				[32m{[m
[32m+[m					[32m"id": "scan-123",[m
[32m+[m					[32m"pipelineId": pipelineID,[m
[32m+[m					[32m"timestamp": time.Now().Add(-24 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"status": "success",[m
[32m+[m					[32m"findings": 5,[m
[32m+[m					[32m"duration": "4.2s",[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"id": "scan-124",[m
[32m+[m					[32m"pipelineId": pipelineID,[m
[32m+[m					[32m"timestamp": time.Now().Add(-12 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"status": "failed",[m
[32m+[m					[32m"findings": 12,[m
[32m+[m					[32m"duration": "3.8s",[m
[32m+[m				[32m},[m
[32m+[m				[32m{[m
[32m+[m					[32m"id": "scan-125",[m
[32m+[m					[32m"pipelineId": pipelineID,[m
[32m+[m					[32m"timestamp": time.Now().Add(-2 * time.Hour).Format(time.RFC3339),[m
[32m+[m					[32m"status": "success",[m
[32m+[m					[32m"findings": 3,[m
[32m+[m					[32m"duration": "4.5s",[m
[32m+[m				[32m},[m
[32m+[m			[32m}[m
[32m+[m[41m			[m
[32m+[m			[32mc.JSON(http.StatusOK, history)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Get a specific scan result[m
[32m+[m		[32msecurityGroup.GET("/scan/:scanId", func(c *gin.Context) {[m
[32m+[m			[32mscanID := c.Param("scanId")[m
[32m+[m[41m			[m
[32m+[m			[32m// In a real implementation, this would load the scan result from a database[m
[32m+[m			[32m// For now, we'll simulate finding a report file[m
[32m+[m			[32mreportPath := filepath.Join("security-reports", fmt.Sprintf("%s.json", scanID))[m
[32m+[m[41m			[m
[32m+[m			[32m// Simulated file reading error[m
[32m+[m			[32mif scanID == "invalid" {[m
[32m+[m				[32mc.JSON(http.StatusNotFound, gin.H{"error": "Scan report not found"})[m
[32m+[m				[32mreturn[m
[32m+[m			[32m}[m
[32m+[m[41m			[m
[32m+[m			[32m// For demo purposes, return mock data[m
[32m+[m			[32mmockData := generateMockScanResult(scanID)[m
[32m+[m			[32mc.JSON(http.StatusOK, mockData)[m
[32m+[m		[32m})[m
[32m+[m
[32m+[m		[32m// Get the latest scan for a pipeline[m
[32m+[m		[32msecurityGroup.GET("/latest/:pipelineId", func(c *gin.Context) {[m
[32m+[m			[32mpipelineID := c.Param("pipelineId")[m
[32m+[m[41m			[m
[32m+[m			[32m// In a real implementation, this would query the most recent scan[m
[32m+[m			[32m// For now, we'll return mock data[m
[32m+[m			[32mmockData := generateMockScanResult("latest-" + pipelineID)[m
[32m+[m			[32mc.JSON(http.StatusOK, mockData)[m
[32m+[m		[32m})[m
[32m+[m	[32m}[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// generateMockScanResult creates mock scan data for demonstration purposes[m
[32m+[m[32mfunc generateMockScanResult(scanID string) map[string]interface{} {[m
[32m+[m	[32mfindingsBySeverity := map[string]int{[m
[32m+[m		[32m"CRITICAL": 1,[m
[32m+[m		[32m"HIGH":     3,[m
[32m+[m		[32m"MEDIUM":   2,[m
[32m+[m		[32m"LOW":      0,[m
[32m+[m		[32m"INFO":     0,[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mfindings := []map[string]interface{}{[m
[32m+[m		[32m{[m
[32m+[m			[32m"ruleId":      "SECRET-001",[m
[32m+[m			[32m"severity":    "CRITICAL",[m
[32m+[m			[32m"description": "AWS Access Key ID detected",[m
[32m+[m			[32m"location":    "config/settings.js",[m
[32m+[m			[32m"lineNumber":  42,[m
[32m+[m			[32m"context":     "const awsKey = 'AKIA[REDACTED]';",[m
[32m+[m			[32m"remediation": "Remove AWS Access Key from code and use environment variables or AWS IAM roles",[m
[32m+[m		[32m},[m
[32m+[m		[32m{[m
[32m+[m			[32m"ruleId":      "CODE-002",[m
[32m+[m			[32m"severity":    "HIGH",[m
[32m+[m			[32m"description": "Potential SQL injection vulnerability",[m
[32m+[m			[32m"location":    "src/controllers/users.js",[m
[32m+[m			[32m"lineNumber":  87,[m
[32m+[m			[32m"context":     "const query = `SELECT * FROM users WHERE id = ${userId}`;",[m
[32m+[m			[32m"remediation": "Use parameterized queries or prepared statements for database operations",[m
[32m+[m		[32m},[m
[32m+[m		[32m{[m
[32m+[m			[32m"ruleId":      "VULN-001",[m
[32m+[m			[32m"severity":    "HIGH",[m
[32m+[m			[32m"description": "Axios before 0.21.2 allows server-side request forgery (CVE-2021-3749)",[m
[32m+[m			[32m"location":    "package.json",[m
[32m+[m			[32m"lineNumber":  15,[m
[32m+[m			[32m"context":     "\"axios\": \"^0.21.1\"",[m
[32m+[m			[32m"remediation": "Update axios to version 0.21.2 or later",[m
[32m+[m		[32m},[m
[32m+[m		[32m{[m
[32m+[m			[32m"ruleId":      "CODE-003",[m
[32m+[m			[32m"severity":    "MEDIUM",[m
[32m+[m			[32m"description": "Hardcoded IP address",[m
[32m+[m			[32m"location":    "src/services/api.js",[m
[32m+[m			[32m"lineNumber":  12,[m
[32m+[m			[32m"context":     "const API_HOST = '192.168.1.100';",[m
[32m+[m			[32m"remediation": "Move IP addresses to configuration files or environment variables",[m
[32m+[m		[32m},[m
[32m+[m		[32m{[m
[32m+[m			[32m"ruleId":      "CODE-001",[m
[32m+[m			[32m"severity":    "HIGH",[m
[32m+[m			[32m"description": "Use of insecure random number generator",[m
[32m+[m			[32m"location":    "src/utils/crypto.js",[m
[32m+[m			[32m"lineNumber":  8,[m
[32m+[m			[32m"context":     "const token = Math.random().toString(36).substring(2);",[m
[32m+[m			[32m"remediation": "Use a cryptographically secure random number generator",[m
[32m+[m		[32m},[m
[32m+[m		[32m{[m
[32m+[m			[32m"ruleId":      "LICENSE-001",[m
[32m+[m			[32m"severity":    "MEDIUM",[m
[32m+[m			[32m"description": "Detected GPL-3.0 license which may conflict with project requirements",[m
[32m+[m			[32m"location":    "node_modules/some-gpl-lib/LICENSE",[m
[32m+[m			[32m"lineNumber":  1,[m
[32m+[m			[32m"context":     "GNU General Public License v3.0",[m
[32m+[m			[32m"remediation": "Review license compatibility with legal team",[m
[32m+[m		[32m},[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32m// Calculate total findings[m
[32m+[m	[32mtotalFindings := 0[m
[32m+[m	[32mfor _, count := range findingsBySeverity {[m
[32m+[m		[32mtotalFindings += count[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mcomponents := []map[string]interface{}{[m
[32m+[m		[32m{[m
[32m+[m			[32m"name":    "axios",[m
[32m+[m			[32m"version": "0.21.1",[m
[32m+[m			[32m"type":    "npm",[m
[32m+[m			[32m"license": "MIT",[m
[32m+[m			[32m"source":  "https://www.npmjs.com/package/axios",[m
[32m+[m			[32m"vulnerabilities": []map[string]interface{}{[m
[32m+[m				[32m{[m
[32m+[m					[32m"id":          "CVE-2021-3749",[m
[32m+[m					[32m"severity":    "HIGH",[m
[32m+[m					[32m"cvss":        8.1,[m
[32m+[m					[32m"description": "Axios before 0.21.2 allows server-side request forgery",[m
[32m+[m					[32m"fixedIn":     "0.21.2",[m
[32m+[m				[32m},[m
[32m+[m			[32m},[m
[32m+[m		[32m},[m
[32m+[m		[32m{[m
[32m+[m			[32m"name":    "lodash",[m
[32m+[m			[32m"version": "4.17.20",[m
[32m+[m			[32m"type":    "npm",[m
[32m+[m			[32m"license": "MIT",[m
[32m+[m			[32m"source":  "https://www.npmjs.com/package/lodash",[m
[32m+[m		[32m},[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mreturn map[string]interface{}{[m
[32m+[m		[32m"id":        scanID,[m
[32m+[m		[32m"timestamp": time.Now().Format(time.RFC3339),[m
[32m+[m		[32m"environment": "development",[m
[32m+[m		[32m"duration":  "5.2s",[m
[32m+[m		[32m"findings":  findings,[m
[32m+[m		[32m"summary": map[string]interface{}{[m
[32m+[m			[32m"totalFiles":         120,[m
[32m+[m			[32m"filesScanned":       98,[m
[32m+[m			[32m"filesSkipped":       22,[m
[32m+[m			[32m"totalFindings":      totalFindings,[m
[32m+[m			[32m"findingsBySeverity": findingsBySeverity,[m
[32m+[m			[32m"passedCheck":        false,[m
[32m+[m		[32m},[m
[32m+[m		[32m"sbom": map[string]interface{}{[m
[32m+[m			[32m"components": components,[m
[32m+[m			[32m"format":     "cyclonedx",[m
[32m+[m			[32m"version":    "1.0",[m
[32m+[m		[32m},[m
[32m+[m	[32m}[m
[32m+[m[32m}[m[41m [m
\ No newline at end of file[m
[1mdiff --git a/api/server.go b/api/server.go[m
[1mnew file mode 100644[m
[1mindex 0000000..94faca9[m
[1m--- /dev/null[m
[1m+++ b/api/server.go[m
[36m@@ -0,0 +1,145 @@[m
[32m+[m[32mpackage api[m
[32m+[m
[32m+[m[32mimport ([m
[32m+[m	[32m"context"[m
[32m+[m	[32m"net/http"[m
[32m+[m	[32m"time"[m
[32m+[m
[32m+[m	[32m"github.com/chip/conveyor/api/routes"[m
[32m+[m	[32m"github.com/chip/conveyor/core"[m
[32m+[m	[32m"github.com/gin-contrib/cors"[m
[32m+[m	[32m"github.com/gin-gonic/gin"[m
[32m+[m	[32m"github.com/gorilla/websocket"[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32m// Server represents the API server[m
[32m+[m[32mtype Server struct {[m
[32m+[m	[32mrouter         *gin.Engine[m
[32m+[m	[32mhttpServer     *http.Server[m
[32m+[m	[32mpipelineEngine *core.PipelineEngine[m
[32m+[m	[32mupgrader       websocket.Upgrader[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// NewServer creates a new API server[m
[32m+[m[32mfunc NewServer(pipelineEngine *core.PipelineEngine) *Server {[m
[32m+[m	[32mrouter := gin.Default()[m
[32m+[m
[32m+[m	[32m// Configure CORS[m
[32m+[m	[32mrouter.Use(cors.New(cors.Config{[m
[32m+[m		[32mAllowOrigins:     []string{"*"},[m
[32m+[m		[32mAllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},[m
[32m+[m		[32mAllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization"},[m
[32m+[m		[32mExposeHeaders:    []string{"Content-Length"},[m
[32m+[m		[32mAllowCredentials: true,[m
[32m+[m		[32mMaxAge:           12 * time.Hour,[m
[32m+[m	[32m}))[m
[32m+[m
[32m+[m	[32mserver := &Server{[m
[32m+[m		[32mrouter:         router,[m
[32m+[m		[32mpipelineEngine: pipelineEngine,[m
[32m+[m		[32mupgrader: websocket.Upgrader{[m
[32m+[m			[32mReadBufferSize:  1024,[m
[32m+[m			[32mWriteBufferSize: 1024,[m
[32m+[m			[32mCheckOrigin: func(r *http.Request) bool {[m
[32m+[m				[32mreturn true // Allow all origins for WebSocket connections[m
[32m+[m			[32m},[m
[32m+[m		[32m},[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32m// Register routes[m
[32m+[m	[32mserver.registerRoutes()[m
[32m+[m
[32m+[m	[32mreturn server[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Start starts the API server[m
[32m+[m[32mfunc (s *Server) Start(addr string) error {[m
[32m+[m	[32ms.httpServer = &http.Server{[m
[32m+[m		[32mAddr:    addr,[m
[32m+[m		[32mHandler: s.router,[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mreturn s.httpServer.ListenAndServe()[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Shutdown gracefully shuts down the API server[m
[32m+[m[32mfunc (s *Server) Shutdown(ctx context.Context) error {[m
[32m+[m	[32mif s.httpServer != nil {[m
[32m+[m		[32mreturn s.httpServer.Shutdown(ctx)[m
[32m+[m	[32m}[m
[32m+[m	[32mreturn nil[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// registerRoutes registers all API routes[m
[32m+[m[32mfunc (s *Server) registerRoutes() {[m
[32m+[m	[32m// Health check[m
[32m+[m	[32ms.router.GET("/api/health", func(c *gin.Context) {[m
[32m+[m		[32mc.JSON(http.StatusOK, gin.H{"status": "ok"})[m
[32m+[m	[32m})[m
[32m+[m
[32m+[m	[32m// Web UI[m
[32m+[m	[32ms.router.GET("/", func(c *gin.Context) {[m
[32m+[m		[32mc.Redirect(http.StatusMovedPermanently, "/ui")[m
[32m+[m	[32m})[m
[32m+[m
[32m+[m	[32m// API routes[m
[32m+[m	[32mroutes.RegisterPipelineRoutes(s.router, s.pipelineEngine)[m
[32m+[m	[32mroutes.RegisterJobRoutes(s.router, s.pipelineEngine)[m
[32m+[m	[32mroutes.RegisterPluginRoutes(s.router)[m
[32m+[m	[32mroutes.RegisterSecurityRoutes(s.router, s.pipelineEngine)[m
[32m+[m[41m	[m
[32m+[m	[32m// WebSocket route for real-time updates[m
[32m+[m	[32ms.router.GET("/api/ws", s.handleWebSocket)[m
[32m+[m
[32m+[m	[32m// Static files for UI[m
[32m+[m	[32ms.router.Static("/ui", "./ui/dist")[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// handleWebSocket handles WebSocket connections for real-time updates[m
[32m+[m[32mfunc (s *Server) handleWebSocket(c *gin.Context) {[m
[32m+[m	[32mconn, err := s.upgrader.Upgrade(c.Writer, c.Request, nil)[m
[32m+[m	[32mif err != nil {[m
[32m+[m		[32mc.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to upgrade connection to WebSocket"})[m
[32m+[m		[32mreturn[m
[32m+[m	[32m}[m
[32m+[m	[32mdefer conn.Close()[m
[32m+[m
[32m+[m	[32m// Create a unique client ID[m
[32m+[m	[32mclientID := c.Query("clientId")[m
[32m+[m	[32mif clientID == "" {[m
[32m+[m		[32mclientID = "client-" + time.Now().Format("20060102-150405.000")[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32m// Register client for event notifications[m
[32m+[m	[32mevents := make(chan core.Event)[m
[32m+[m	[32ms.pipelineEngine.RegisterEventListener(clientID, events)[m
[32m+[m	[32mdefer s.pipelineEngine.UnregisterEventListener(clientID)[m
[32m+[m
[32m+[m	[32m// Create a context that's cancelled when the connection is closed[m
[32m+[m	[32mctx, cancel := context.WithCancel(c.Request.Context())[m
[32m+[m	[32mdefer cancel()[m
[32m+[m
[32m+[m	[32m// Read messages from client in a separate goroutine[m
[32m+[m	[32mgo func() {[m
[32m+[m		[32mdefer cancel()[m
[32m+[m		[32mfor {[m
[32m+[m			[32m_, _, err := conn.ReadMessage()[m
[32m+[m			[32mif err != nil {[m
[32m+[m				[32mreturn // Connection closed[m
[32m+[m			[32m}[m
[32m+[m		[32m}[m
[32m+[m	[32m}()[m
[32m+[m
[32m+[m	[32m// Send events to client[m
[32m+[m	[32mfor {[m
[32m+[m		[32mselect {[m
[32m+[m		[32mcase event := <-events:[m
[32m+[m			[32merr := conn.WriteJSON(event)[m
[32m+[m			[32mif err != nil {[m
[32m+[m				[32mreturn // Connection closed[m
[32m+[m			[32m}[m
[32m+[m		[32mcase <-ctx.Done():[m
[32m+[m			[32mreturn // Context cancelled[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m[32m}[m[41m [m
\ No newline at end of file[m
[1mdiff --git a/cli/main.go b/cli/main.go[m
[1mnew file mode 100644[m
[1mindex 0000000..3bc1f6c[m
[1m--- /dev/null[m
[1m+++ b/cli/main.go[m
[36m@@ -0,0 +1,46 @@[m
[32m+[m[32mpackage main[m
[32m+[m
[32m+[m[32mimport ([m
[32m+[m	[32m"fmt"[m
[32m+[m	[32m"log"[m
[32m+[m	[32m"net/http"[m
[32m+[m	[32m"os"[m
[32m+[m	[32m"os/signal"[m
[32m+[m	[32m"syscall"[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mfunc main() {[m
[32m+[m	[32mport := os.Getenv("PORT")[m
[32m+[m	[32mif port == "" {[m
[32m+[m		[32mport = "8080"[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32m// Create simple HTTP server[m
[32m+[m	[32mhttp.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {[m
[32m+[m		[32mfmt.Fprintf(w, "Conveyor API Server")[m
[32m+[m	[32m})[m
[32m+[m
[32m+[m	[32mhttp.HandleFunc("/api/health", func(w http.ResponseWriter, r *http.Request) {[m
[32m+[m		[32mw.Header().Set("Content-Type", "application/json")[m
[32m+[m		[32mfmt.Fprintf(w, `{"status":"ok"}`)[m
[32m+[m	[32m})[m
[32m+[m
[32m+[m	[32mhttp.HandleFunc("/api/pipelines", func(w http.ResponseWriter, r *http.Request) {[m
[32m+[m		[32mw.Header().Set("Content-Type", "application/json")[m
[32m+[m		[32mfmt.Fprintf(w, `[]`)[m
[32m+[m	[32m})[m
[32m+[m
[32m+[m	[32m// Start server[m
[32m+[m	[32mgo func() {[m
[32m+[m		[32mlog.Printf("Starting server on :%s", port)[m
[32m+[m		[32mif err := http.ListenAndServe(":"+port, nil); err != nil {[m
[32m+[m			[32mlog.Fatalf("Failed to start server: %v", err)[m
[32m+[m		[32m}[m
[32m+[m	[32m}()[m
[32m+[m
[32m+[m	[32m// Wait for interrupt signal to gracefully shut down the server[m
[32m+[m	[32mquit := make(chan os.Signal, 1)[m
[32m+[m	[32msignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)[m
[32m+[m	[32m<-quit[m
[32m+[m	[32mlog.Println("Shutting down server...")[m
[32m+[m[32m}[m[41m [m
\ No newline at end of file[m
[1mdiff --git a/core/pipeline.go b/core/pipeline.go[m
[1mnew file mode 100644[m
[1mindex 0000000..02447b4[m
[1m--- /dev/null[m
[1m+++ b/core/pipeline.go[m
[36m@@ -0,0 +1,428 @@[m
[32m+[m[32mpackage core[m
[32m+[m
[32m+[m[32mimport ([m
[32m+[m	[32m"context"[m
[32m+[m	[32m"encoding/json"[m
[32m+[m	[32m"fmt"[m
[32m+[m	[32m"sync"[m
[32m+[m	[32m"time"[m
[32m+[m
[32m+[m	[32m"github.com/google/uuid"[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32m// Pipeline represents a CI/CD pipeline[m
[32m+[m[32mtype Pipeline struct {[m
[32m+[m	[32mID          string                 `json:"id"`[m
[32m+[m	[32mName        string                 `json:"name"`[m
[32m+[m	[32mDescription string                 `json:"description"`[m
[32m+[m	[32mSteps       []Step                 `json:"steps"`[m
[32m+[m	[32mStatus      string                 `json:"status"`[m
[32m+[m	[32mCreatedAt   time.Time              `json:"createdAt"`[m
[32m+[m	[32mUpdatedAt   time.Time              `json:"updatedAt"`[m
[32m+[m	[32mCache       map[string]interface{} `json:"cache,omitempty"`[m
[32m+[m	[32mMetadata    map[string]interface{} `json:"metadata,omitempty"`[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Step represents a step in a pipeline[m
[32m+[m[32mtype Step struct {[m
[32m+[m	[32mID       string                 `json:"id"`[m
[32m+[m	[32mName     string                 `json:"name"`[m
[32m+[m	[32mType     string                 `json:"type"`[m
[32m+[m	[32mConfig   